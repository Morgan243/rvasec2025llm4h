# Only used to clear the clipboard by copying a ' ' after invoking exploitdb's searchsploit
import pyperclip

import os
import pandas as pd
from dataclasses import dataclass, field
from typing import List, Optional, Any, Tuple
from simple_parsing import Serializable
from functools import cached_property
import subprocess
import json

import time


def run_subprocess(command: List[str],
                   do_stupid_copy_trick: bool = False) -> Tuple[Optional[str], Optional[str]]:
    """
    Run a subprocess and capture its output and error.

    Parameters
    ----------
    command : List[str]
        The command to run as a list of arguments.

    Returns
    -------
    Tuple[Optional[str], Optional[str]]
        A tuple containing the standard output and standard error.
    """
    try:
        result = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        if do_stupid_copy_trick:
            time.sleep(.5)
            # If the system doesn't have a clip board (e.g., headless server), this will
            # throw an exception
            try: pyperclip.copy(' ')
            except: pass
        output = result.stdout.read()
        error = result.stderr.read()
        return output.decode('utf-8'), error.decode('utf-8') if error else None
    except FileNotFoundError:
        return None, "Executable not found."


def run_subprocess_new(command: List[str]) -> Tuple[Optional[str], Optional[str]]:
    print("in new run subprocess!")
    result = subprocess.run(command, capture_output=True, text=True, check=True)
    return result.stdout, result.stderr


@dataclass
class ExploitDB(Serializable):
    root_directory: str
    search_sploit_path: str = field(default=None, init=None)

    additional_default_flags: Optional[list[str]] = field(default_factory=list)

    def __post_init__(self):
        self.search_sploit_path = os.path.join(self.root_directory, 'searchsploit')

    @cached_property
    def sys_has_clipboard(self) -> bool:
        """
        Whether the system has a clipboard that exploitdb's searchsploit will try to 
        copy the full path into... which might be useful, but it causes the invoke to
        block. This is why pyperclip is required
        """

        has_clipboard = True
        # If the system doesn't have a clip board (e.g., headless server), this will
        # throw an exception
        try: pyperclip.copy(' ')
        except: 
            has_clipboard = False
        return has_clipboard

    def list_exploits(self) -> List[str]:
        """List all exploits in the ExploitDB directory."""
        import os
        return [f for f in os.listdir(self.root_directory) if os.path.isfile(os.path.join(self.root_directory, f))]

    @cached_property
    def help_string(self):
        """Get the help string from searchsploit."""
        command = [self.search_sploit_path, '-h']
        output, error = run_subprocess(command)
        if error:
            return f"Error: {error}"
        else:
            return output

    def print_help(self) -> str:
        """Invoke searchsploit with --help argument using popen."""
        print(self.help_string)
        return self.help_string

    def searchsploit(self, *args: str) -> str:
        args = self.additional_default_flags + list(args)
        command = [self.search_sploit_path] + args
        #print(" ".join(command))
        
        output, _ = run_subprocess(command,
                                   do_stupid_copy_trick='-p' in command or '--path' in command)
        return output

    def searchsploit_as_json(self, *args: str,
                             deserialize_results: bool = True) -> str | Any:
        args = self.additional_default_flags + list(args)
        if not any(_j in args for _j in ['-j', '--json']):
            args = list(['-j'] + list(args))
        o = self.searchsploit(*args)
        o = json.loads(o) if deserialize_results else o
        return o

    def examine_edb_id(self, ebd_id: str):
        ebd_metadata = self.searchsploit('--path', str(ebd_id))
        path_keyword = 'Path: '
        path_line = [ln for ln in ebd_metadata.splitlines() if path_keyword in ln][0]
        from pathlib import Path
        p = Path(path_line.replace(path_keyword, '').strip())
        with open(p, 'r') as f:
            content = f.read()
        return content

    @staticmethod
    def flatten_cve_results(results) -> list[dict]:
        """
            Flattens the given CVE results to a simple list of dictionaries.
            
            Args:
                results (dict): A dictionary containing CVE search results.
                
            Returns:
                list: A flattened list of dictionaries with high-level summaries of each CVE.
        """
        flattened_results = []

        # Flatten RESULTS_EXPLOIT
        for item in results['RESULTS_EXPLOIT']:
            flattened_item = {
                'Title': item['Title'],
                'EDB-ID': item['EDB-ID'],
                'Date_Published': item['Date_Published'],
                'Author': item['Author'],
                'Type': item['Type'],
                'Platform': item['Platform'],
                'Verified': item['Verified'],
                'Source': 'exploit-db:exploit'
            }
            flattened_results.append(flattened_item)

        # Flatten RESULTS_SHELLCODE
        for item in results['RESULTS_SHELLCODE']:
            flattened_item = {
                'Title': item['Title'],
                'EDB-ID': item['EDB-ID'],
                'Date_Published': item['Date_Published'],
                'Author': item['Author'],
                'Type': item['Type'],
                'Platform': item['Platform'],
                'Verified': item['Verified'],
                'Source': 'exploit-db:shellcode'
            }
            flattened_results.append(flattened_item)

        return flattened_results

    def searchsploit_as_summary(self, *args: str,
                                fields: list[str] = None,
                                n: int = None) -> str:
        fields = ['index', 'Title'] if fields is None else fields
        json_dat = self.searchsploit_as_json(*args)
        df = pd.DataFrame(self.flatten_cve_results(json_dat))
        _df = df.reset_index()[fields]
        _df = _df if n is None else _df.head(n)
        return _df.to_json()

#def test():
#cmd = ['/home/morgan/Projects/EXTERNAL/exploitdb/searchsploit', '--path', '3333']
#run_subprocess(cmd)

#exploit_db = ExploitDB('/home/morgan/Projects/EXTERNAL/exploitdb',
#                              additional_default_flags=[
#                              #'--www',
#                              #'-j',
#                              #'--id',
#                              #'--disable-color'
#                       ]
#                       )
#print(exploit_db.examine_edb_id("32813"))



